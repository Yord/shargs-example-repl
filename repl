#!/usr/bin/env node

const {parserSync} = require('shargs')
const {subcommand, command, string, stringPos, variadic} = require('shargs-opts')
const {restrictToOnly} = require('shargs-parser')
const {desc, optsDef, optsLists, space, synopsis, usage} = require('shargs-usage')
const repl = require('repl')

const echoCmd = subcommand([
  stringPos('text', {desc: 'This text is echoed.'})
])

const caseCmd = subcommand([
  stringPos('text', {desc: 'This text is transformed into upper or lower case.'}),
  string('mode', ['--mode'], {only: ['upper', 'lower'], desc: 'How to transform the text.'})
])

const opts = [
  echoCmd('echo', ['echo'], {desc: 'Echos a string.'}),
  caseCmd('case', ['case'], {desc: 'Transforms its argument into upper or lower case depending on the --mode.'}),
  variadic('help', ['help'], {desc: 'Print usage documentation.'})
]

const commands = command('shargs', opts)

const stages = {
  toArgv,
  opts: [restrictToOnly],
  fromArgs
}

const parse = parserSync(stages)(commands)

const exec = {
  echo,
  case: caseF,
  help
}

repl.start( {
  prompt: 'shargs $ ',
  ignoreUndefined: true,
  eval: eval(parse, exec)
})

function eval(parse, exec) {
  return (cmd, context, filename, callback) => {
    const {errs, args} = parse(cmd)

    const strings = Object.keys(args).map(key =>
      (exec[key] || (_ => ''))(args[key])
    )
  
    const output = (
      errs.length > 0 ? errs.map(({code, msg}) => `${code}: ${msg}`).join('\n')
                      : strings.join('\n')
    )
  
    console.log(output)
  
    callback(null, undefined);
  }
}

function strToArgv (string) {
  const argv = []

  let inString = false
  let token    = ''

  for (let i = 0; i < string.length; i++) {
    const ch = string[i]

    if (!isLinebreak(ch)) {
      if (inString) {
        if (isStringLiteral(ch)) {
          inString = false
        } else {
          token += ch
        }
      } else {
        if (isStringLiteral(ch)) {
          inString = true
        } else if (isWhitespace(ch)) {
          argv.push(token)
          token = ''
        } else {
          token += ch
        }
      }
    }
  }

  if (token !== '') argv.push(token)

  return argv
}

function echo ({text}) {
  return text
}

function caseF ({text, mode}) {
  switch (mode) {
    case 'upper': return text.toUpperCase()
    case 'lower': return text.toLowerCase()
    default:      return text
  }
}

function help (command) {
  const docs    = usage([optsLists, space, desc])
  const subDocs = usage([synopsis, space, optsDef, space, desc])
  
  const style = {
    line: [{width: 80}],
    cols: [{width: 25, padEnd: 2}, {width: 53}]
  }

  if (isEmptyArray(command)) {
    return docs(commands)(style)
  }

  const command2 = Array.isArray(command) ? command : [command]
  const subcommands = commands.opts.filter(({key}) => command2.includes(key))
  const helps = subcommands.map(cmd => subDocs(cmd)(style))
  return helps.join('\n')
}

function isUndefined (a) {
  return typeof a === 'undefined'
}

function isEmptyArray (a) {
  return Array.isArray(a) && a.length === 0
}

function isLinebreak (ch) {
  return ch === '\n'
}

function isStringLiteral (ch) {
  return ch === '"' || ch === "'"
}

function isWhitespace (ch) {
  return ch === ' '
}

function toArgv (str) {
  return {
    errs: [],
    argv: strToArgv(str)
  }
}

function fromArgs ({errs, args}) {
  return {
    errs,
    args: isUndefined(args[1]) ? args[0] : args[1]
  }
}